# 영속성 관리

### 엔티티 매니저 팩토리

```java
// META-INF/persistence.xml에 있는 정보를 바탕으로 정의된 영속성 유닛에 해당하는 EntityManagerFactory를 생성
EntityManagerFactory emf = Persistence.createEntityManagerFactory("persistence_unit_name");
```

- 엔티티 매니저를 만드는 공장의 개념 
- 생성 비용이 크므로 한 번만 생성하여 애플리케이션 전체에서 공유
- **여러 스레드가 동시에 접근해도 안전**

### 엔티티 매니저

```java
EntityManager em = emf.createEntityManager();
```

- 엔티티를 저장, 수정, 삭제, 조회 등 엔티티와 관련된 모든 일을 처리하는 엔티티 관리자
- 엔티티를 저장하는 가상의 데이터베이스로 생각하면 됨
- **여러 스레드가 동시에 접근하면 동시성 문제가 발생**

### 영속성 컨텍스트

#### 정의

- 엔티티를 영구 저장하는 환경 _Persistence Context_
- 엔티티 매니저를 생성할 때 만들어지고, 엔티티 매니저를 통해 접근과 관리가 가능
- 엔티티 매니저를 이용해 엔티티를 저장하거나 조회하면\
엔티티 매니저는 이들을 **영속성 컨텍스트에 엔티티를 보관하고 관리**

#### 생명주기

- `비영속` _new/transient_ : 영속성 컨텍스트와 전혀 관계가 없는 상태
- `영속` _managed_ : 영속성 컨텍스트에 저장된 상태
- `준영속` _detached_ : 영속성 컨텍스트에 저장되었다가 분리된 상태
- `삭제` _removed_ : 삭제된 상태

![](https://www.objectdb.com/files/images/manual/jpa-states.png) [(참고)](https://www.objectdb.com)

### 영속성 컨텍스트의 특징

- **식별자 값 필수**\
식별자 값으로 구분되기 때문에 영속 상태는 식별자 값이 반드시 있어야 한다
- **데이터베이스 저장**\
트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영 _flush_
- **장점**\
1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기지연, 변경 감지, 지연 로딩

#### 1) 엔티티 조회

- 영속성 컨텍스트는 내부에 캐시 _1차 캐시_ 를 가지고 있고,\
영속 상태의 엔티티를 모두 이곳에 저장한다
- `find()` 호출시 먼저 **1차 캐시**에서 엔티티를 찾아 반환하고,\
존재하지 않으면 이후에 **데이터베이스**에서 조회하여 반환한다
- DB 조회로 새로 생성된 엔티티 또한 1차 캐시에 저장후 영속 상태가 된다

#### 2) 영속 엔티티의 동일성 보장

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");
System.out.println(a == b); // true
```

- find()를 반복해서 호출해도 영속성 컨텍스트는 1차 캐시에 있는 **같은 값**을 반환
- 따라서 a와 b는 같은 인스턴스이므로 a == b의 결과는 true

#### 3) 트랜잭션 쓰기 지연

- 엔티티 매니저는 트랜잭션을 커밋하기 전까지 DB에 데이터를 저장하지 않고\
**내부 쿼리 저장소**에 INSERT SQL을 모아둠 _transactional write-behind_
- 이후 commit()을 호출하면 우선 영속성 컨텍스트가 `flush` 되는데,\
즉 쓰기지연 SQL 저장소에 모아둔 쿼리를 DB에 보내고 트랜잭션을 커밋
- 이 기능을 잘 활용하면 커밋 직전에만 DB에 접근하여 성능을 최적화할 수 있음

#### 4) 엔티티 수정: 변경감지

- SQL 기반의 개발은 비즈니스 로직이 SQL에 의존적일 수밖에 없음
- JPA는 조회해온 엔티티를 수정하고 커밋하기만 하면 수정사항이 자동으로 반영 _dirty checking_
- 엔티티를 영속성 컨텍스트에 저장할 때 최초 상태를 복사한 `스냅샷`을 저장
- flush 시점에 이 스냅샷과 엔티티를 비교하여 변경된 엔티티를 찾아내서\
수정 쿼리를 쓰기 지연 SQL에 저장한 뒤 커밋시 반영한다
- **변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용**
- JPA는 UPDATE SQL을 실행할 때 기본적으로 **모든 필드**를 업데이트하기 때문에\
필드가 너무 많거나 저장되는 내용이 크면 확장 기능인 동적 UPDATE SQL을 사용해야 함

#### 5) 엔티티 삭제

- remove() 메소드에 엔티티를 인자로 넘겨주면 해당 엔티티는 삭제되고\
영속성 컨텍스트에서도 제거된다
- 마찬가지로 쓰기 지연 SQL 저장소에 등록, 커밋 과정을 거침

### 플러시

- `flush()`는 **영속성 컨텍스트의 변경 내용을 데이터베이스에 반영(동기화)**  하는 작업
- 메소드를 직접 호출하거나, 트랜잭션 커밋 혹은 JPQL 쿼리 실행시 자동으로 호출된다
- `javax.persistence.FlushModeType`을 사용해 플러시 모드 옵션을 바꿀 수 있다 (기본 AUTO)

#### 동작 과정

1. 변경 감지가 동작해 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교하여 수정된 엔티티 찾기
2. 수정된 엔티티는 수정 쿼리를 생성해 SQL 저장소에 등록
3. 저장소에 있는 쿼리를 데이터베이스에 전송

#### 호출 방법

- **직접 호출**\
영속성 컨텍스트를 강제로 플러시하는 방법으로, 거의 사용되지 않는다
- **트랜잭션 커밋시 자동 호출**\
DB에 변경 내용을 전달하고 커밋해야 반영이 되므로 JPA는 자동으로 커밋시 호출하도록 한다
- **JPQL 쿼리 실행시 자동 호출**\
영속성 컨텍스트에는 존재하지만 DB에는 없는 경우 발생하는 문제를 예방하기 위해 쿼리 실행시 호출된다