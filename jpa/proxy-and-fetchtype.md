# 프록시와 연관관계 관리

### 프록시

- 연관관계에 있는 엔티티들이 늘 함께 사용되는 것은 아님
- 회원과 팀이 연관관계에 있을 때, 회원만 조회하는 경우\
팀을 굳이 함께 조회해두는 것은 비효율적
- JPA에서 엔티티가 실제로 사용될 때까지 조회를 지연하는 방법을 제공
- 지연 로딩 사용을 위해서는 `프록시 객체`라는 가짜 객체를 사용
- 프록시 객체는 실제 객체에 대한 참조(target)를 보관
- 프록시 객체의 메소드를 호출하면 실제 객체의 메소드를 호출

#### 초기화

```java
Member member = em.getReference(Member.class, "id1"); // Member의 프록시 객체를 반환한다
member.getName(); // 프록시 초기화
```

- 프록시 객체를 사용해 getName()과 같이 메소드를 호출할 때 실제 엔티티가 생성되어 있지 않으면\
영속성 컨텍스트에 실제 엔티티 생성을 요청하는 것을 프록시 초기화라고 한다
- 영속성 컨텍스트가 DB 조회로 실제 엔티티 객체를 생성하면\
이 객체의 참조를 프록시의 target 멤버변수에 보관한다
- 프록시 객체는 실제 엔티티 객체의 메소드를 호출해서 데이터를 반환
- 첫 사용시 한 번만 초기화되고, 초기화를 한다고 해서\
프록시 객체가 엔티티로 바뀌는 것이 아니라 엔티티에 접근할 수 있게 되는 것이다
- 영속성 컨텍스트에 이미 실제 엔티티가 있으면\
getReference()의 반환값은 프록시가 아닌 실제 엔티티가 된다

#### 식별자

```java
Team team = em.getReference(Team.class, "team1"); // 식별자 보관
team.getId(); // 프록시를 초기화하지 않음
```

- 엔티티의 접근 방식이 프로퍼티 `@Access(AccessType.PROPERTY)` 설정인 경우\
프록시 조회를 위해 getReference의 파라미터로 전달받은 식별자를 보관한다
- getId()가 호출되어도 프록시를 초기화하지 않는다
- 반면에 접근방식이 `@Access(AccessType.FIELD)`인 경우에는 프록시 객체를 초기화한다
- ID만 가지고 연관관계를 설정하는 경우 등에 사용하면\
데이터베이스 접근 횟수를 줄임으로써 효율성을 높일 수 있다

### 즉시 로딩과 지연 로딩

- 프록시 객체는 주로 연관된 엔티티를 `지연 로딩`할 때 사용
- JPA는 엔티티의 조회 시점을 지정할 수 있는 방법 두 가지를 제공한다

#### 즉시 로딩

- 엔티티 조회시 연관된 엔티티를 함께 조회
- `fetch=FetchType.EAGER` 으로 설정
- JPA는 최적화를 위해 가능하면 조인 쿼리를 사용해\
한 번에 두 엔티티를 모두 조회
- **외부 조인과 내부 조인**\
외래 키의 null 조건 여부에 따라 JPA는 외부/내부 조인을 선택한다\
보통 내부 조인이 성능과 최적화에 더 유리하기 때문에 NOT NULL 조건을 설정하는 것이 좋다
- NOT NULL 조건 설정하기
  + `@JoinColumn`의 속성으로 (nullable=false) 주기
  + `@ManyToOne`의 속성으로 (optional=false) 주기

#### 지연 로딩

```java
Member member = em.find(Member.class, "myId");
Team team = member.getTeam(); // 프록시 객체를 저장
team.getName(); // 실제 사용 (이때 프록시가 초기화된다)
```

- 연관된 엔티티가 실제로 사용될 때 조회
- `fetch=FetchType.LAZY` 으로 설정

#### JPA 기본 페치 전략

- **즉시 로딩**: `@ManyToOne`, `@OneToOne`
- **지연 로딩**: `@OneTomany`, `@ManyToMany`
- 연관 엔티티가 하나인 경우 즉시 로딩,\
컬렉션이면 지연 로딩을 사용한다.
- **모든 연관관계에 지연 로딩을 사용**하고 개발완료 단계에 가까워졌을 때\
실무 상황을 보고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화하는 것이 좋다.

#### 컬렉션에 즉시 로딩 사용시 유의점

1. **2개 이상의 컬렉션을 즉시 로딩**으로 설정하는 경우 애플리케이션 성능의 저하 우려가 크기 때문에 **권장되지 않는다**
2. **항상 외부 조인 _OUTER JOIN_ 을 사용하는 것이 좋다**\
일대다 관계에서 not null이 있는 컬럼은 내부 조인시 제대로 조회되지 않을 수 있다\
따라서 JPA는 일대다 관계를 즉시 로딩할 때 항상 외부 조인을 사용한다

### 영속성 전이

- 특정 엔티티를 영속 상태로 만들면서 다른 연관된 엔티티도 같이 영속상태로 만들고 싶을 때 사용
- 부모 엔티티를 저장할 때 자식 엔티티도 같이 저장

```java
// Parent 클래스 내부
@OneToMany(mappedBy="parent", 
	cascade={CascadeType.PERSIST, CascadeType.REMOVE}) // 영속성 전이 설정
private List<Child> children = new ArrayList<Child>();

// 영속성 전이 추가
Child c1 = new Child();
Child c2 = new Child();
Parent p = new Parent();

c1.setParent(p); // 연관관계 추가
c2.setParent(p); // 연관관계 추가
p.getChildren().add(c1);
p.getChildren().add(c2);
em.persist(p);

// 영속성 전이 삭제
em.remove(p);
```

- 자식 참조 필드에 `cascade` 속성을 사용하면\
간편하게 부모와 자식 엔티티를 한 번에 영속할 수 있게 된다
- 저장할 때는 연관관계를 먼저 추가한 다음 영속 상태로 만들어야 한다
- 삭제할 때는 부모와 자식이 함께 삭제된다

### 고아 객체

- 부모 엔티티와 연관관계가 끊어진 자식 엔티티,\
즉 참조가 제거된 엔티티를 고아 객체라고 한다
- JPA는 이 고아 객체를 자동으로 삭제하는 기능을 제공한다
- 부모 엔티티에 있는 자식 엔티티의 참조에 `orphanRemoval=true` 옵션으로 설정
- 한 곳에서만 참조하는 일대일이나 일대다 관계에서만 사용할 수 있다
- `CascadeTye.REMOVE`의 기능적인 면과 일치한다

